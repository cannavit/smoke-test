"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const helper_1 = require("../helper");
const errors_1 = require("../errors");
const windows_1 = __importDefault(require("./windows"));
const mac_1 = __importDefault(require("./mac"));
const linux_1 = __importDefault(require("./linux"));
const messages_1 = require("../messages");
//create instance of parser based on operating system
function parserFactory(platform, output, options) {
    let parser;
    let isWindows = false;
    if (!helper_1.isPlatformSupported(platform)) {
        throw new errors_1.supportedError(messages_1.ERROR_MESSAGES.PLATFORM_NOT_SUPPORTED.replace('platform', platform));
    }
    if (platform === 'win32') {
        parser = new windows_1.default(defaultResponse, options);
        isWindows = true;
    }
    else if (platform === 'darwin') {
        parser = new mac_1.default(defaultResponse, options);
    }
    else {
        parser = new linux_1.default(defaultResponse, options);
    }
    let result = parseOutput(parser, isWindows, output);
    return result;
}
//parsing output line by line
function parseOutput(parser, isWindows, output) {
    let lines = output === null || output === void 0 ? void 0 : output.join('').split('\n');
    let state = 0;
    let parsedOutput = defaultResponse;
    lines === null || lines === void 0 ? void 0 : lines.forEach((line) => {
        line = line.replace(stripRegex, '');
        if (line.length === 0) {
            // Do nothing if this is an empty line
        }
        else if (state === states.HEADER) {
            parser.processHeader(line);
            state = states.BODY;
        }
        else if (state === states.BODY) {
            (!checkIfBodyEnded(line, isWindows)) ? parser.processBody(line) : state = states.FOOTER;
        }
        else if (state === states.FOOTER) {
            parsedOutput = parser.processFooter(line);
        }
    });
    let result = createResult(parsedOutput, lines);
    return result;
}
//function to check if body ended and footer began
function checkIfBodyEnded(line, windows) {
    if (windows) {
        let isPingSummaryLineShown = line.slice(-1) === ':';
        if (isPingSummaryLineShown) {
            return true;
        }
    }
    else {
        // Change state if it see a '---'
        if (line.indexOf('---') >= 0) {
            return true;
        }
    }
    return false;
}
//Function to calculate and create the result
function createResult(result, lines) {
    var _a;
    // Concat output
    result.output = lines === null || lines === void 0 ? void 0 : lines.join('\n');
    // Determine alive
    result.alive = ((_a = result === null || result === void 0 ? void 0 : result.times) === null || _a === void 0 ? void 0 : _a.length) > 0;
    // Update time at first successful line
    if (result.alive) {
        result.time = result.times[0];
    }
    // Get stddev
    if (result.stddev === undefined && result.alive) {
        let N = result.times.length;
        const mean = result.times.reduce((a, b) => a + b) / N;
        const stddev = Math.sqrt(result.times.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / N);
        result.stddev = stddev;
    }
    // Fix min, avg, max, stddev up to 3 decimal points
    ['min', 'avg', 'max', 'stddev', 'packetLoss'].forEach((key) => {
        let v = result[key];
        if (typeof v === 'number') {
            result[key] = v.toFixed(3);
        }
    });
    return result;
}
//Default response object
const defaultResponse = {
    host: undefined,
    numericHost: undefined,
    alive: false,
    output: undefined,
    time: undefined,
    times: [],
    min: undefined,
    max: undefined,
    avg: undefined,
    stddev: undefined,
    packetLoss: undefined,
    bufferSize: undefined
};
//to strip space present at end of string
const stripRegex = /[ ]*\r?\n?$/g;
//States of parsing - local use only
const states = {
    HEADER: 0,
    BODY: 1,
    FOOTER: 2
};
exports.default = parserFactory;
