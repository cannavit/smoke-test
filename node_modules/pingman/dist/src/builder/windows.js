"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const process_1 = require("process");
const messages_1 = require("../messages");
const windows = (ip, options) => {
    let args = [];
    const windowsRootPath = process.env.SystemRoot + '/system32/ping.exe';
    args.push(ip);
    //NO Allowing Unsanitized user input into spawn.Checking each param and assigning
    if (!options) {
        return {
            command: windowsRootPath,
            arguments: args
        };
    }
    else {
        if (options === null || options === void 0 ? void 0 : options.numeric) {
            args.push('-a');
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.numberOfEchos) === 'number') {
            args.push('-n', options.numberOfEchos.toString());
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.bufferSize) === 'number') {
            args.push('-l', options.bufferSize.toString());
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.TTL) === 'number') {
            args.push('-i', options.TTL.toString());
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.timeout) === 'number') {
            args.push('-w', (options.timeout * 1000).toString());
        }
        args.push(...(checkForIpV4SpecificFields(options)));
        args.push(...(checkForIpV6SpecificFields(options)));
    }
    return {
        command: windowsRootPath,
        arguments: args
    };
};
//Checking for windows IPV4 fields as per official documentation
function checkForIpV4SpecificFields(options) {
    let optionsUsed = "";
    let args = [];
    if (options === null || options === void 0 ? void 0 : options.IPV4) {
        args.push('-4');
        if (options.doNotFragment) {
            args.push('-f');
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.recordRouteHops) === 'number') {
            args.push('-r', options.recordRouteHops.toString());
        }
        if (typeof (options === null || options === void 0 ? void 0 : options.hopTimestamp) === 'number') {
            args.push('-s', options.hopTimestamp.toString());
        }
    }
    else {
        if (options.doNotFragment) {
            optionsUsed.concat(',', options.doNotFragment.toString());
        }
        if (options.recordRouteHops) {
            optionsUsed.concat(',', options.recordRouteHops.toString());
        }
        if (options.hopTimestamp) {
            optionsUsed.concat(',', options.hopTimestamp.toString());
        }
        if (optionsUsed.length > 0) {
            process_1.emitWarning(messages_1.ERROR_MESSAGES.ENABLE_IPV4_EXPLICIT.replace('commands', optionsUsed), 'IPV4OnlyWarning');
        }
    }
    return args;
}
//Checking for windows IPV6 fields as per official documentation
function checkForIpV6SpecificFields(options) {
    let optionsUsed = "";
    let args = [];
    if (options === null || options === void 0 ? void 0 : options.IPV6) {
        args.push('-6');
        if (options.srcAddr) {
            args.push('-S', options.srcAddr);
        }
    }
    else {
        if (typeof options.srcAddr === 'string') {
            optionsUsed.concat(',', options.srcAddr);
        }
        if (optionsUsed.length > 0) {
            process_1.emitWarning(messages_1.ERROR_MESSAGES.ENABLE_IPV6_EXPLICIT.replace('commands', optionsUsed), 'IPV6OnlyWarning');
        }
    }
    return args;
}
exports.default = windows;
