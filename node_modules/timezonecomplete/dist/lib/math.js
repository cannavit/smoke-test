/**
 * Copyright(c) 2014 ABB Switzerland Ltd.
 *
 * Math utility functions
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var assert_1 = require("./assert");
/**
 * @return true iff given argument is an integer number
 * @throws nothing
 */
function isInt(n) {
    if (n === null || !isFinite(n)) {
        return false;
    }
    return (Math.floor(n) === n);
}
exports.isInt = isInt;
/**
 * Rounds -1.5 to -2 instead of -1
 * Rounds +1.5 to +2
 * @throws timezonecomplete.Argument.N if n is not a finite number
 */
function roundSym(n) {
    assert_1.default(Number.isFinite(n), "Argument.N", "n must be a finite number but is: %d", n);
    if (n < 0) {
        return -1 * Math.round(-1 * n);
    }
    else {
        return Math.round(n);
    }
}
exports.roundSym = roundSym;
/**
 * Stricter variant of parseFloat().
 * @param value	Input string
 * @return the float if the string is a valid float, NaN otherwise
 * @throws nothing
 */
function filterFloat(value) {
    if (/^(\-|\+)?([0-9]+(\.[0-9]+)?|Infinity)$/.test(value)) {
        return Number(value);
    }
    return NaN;
}
exports.filterFloat = filterFloat;
/**
 * Modulo function that only returns a positive result, in contrast to the % operator
 * @param value
 * @param modulo
 * @throws timezonecomplete.Argument.Value if value is not finite
 * @throws timezonecomplete.Argument.Modulo if modulo is not a finite number >= 1
 */
function positiveModulo(value, modulo) {
    assert_1.default(Number.isFinite(value), "Argument.Value", "value should be finite");
    assert_1.default(Number.isFinite(modulo) && modulo >= 1, "Argument.Modulo", "modulo should be >= 1");
    if (value < 0) {
        return ((value % modulo) + modulo) % modulo;
    }
    else {
        return value % modulo;
    }
}
exports.positiveModulo = positiveModulo;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvbWF0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7OztHQUlHO0FBRUgsWUFBWSxDQUFDOztBQUViLG1DQUE4QjtBQUU5Qjs7O0dBR0c7QUFDSCxTQUFnQixLQUFLLENBQUMsQ0FBUztJQUM5QixJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDL0IsT0FBTyxLQUFLLENBQUM7S0FDYjtJQUNELE9BQU8sQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO0FBQzlCLENBQUM7QUFMRCxzQkFLQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFnQixRQUFRLENBQUMsQ0FBUztJQUNqQyxnQkFBTSxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLEVBQUUsWUFBWSxFQUFFLHNDQUFzQyxFQUFFLENBQUMsQ0FBQyxDQUFDO0lBQ3BGLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRTtRQUNWLE9BQU8sQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUMvQjtTQUFNO1FBQ04sT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3JCO0FBQ0YsQ0FBQztBQVBELDRCQU9DO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixXQUFXLENBQUMsS0FBYTtJQUN4QyxJQUFJLHdDQUF3QyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN6RCxPQUFPLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNyQjtJQUNELE9BQU8sR0FBRyxDQUFDO0FBQ1osQ0FBQztBQUxELGtDQUtDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsY0FBYyxDQUFDLEtBQWEsRUFBRSxNQUFjO0lBQzNELGdCQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRSxnQkFBZ0IsRUFBRSx3QkFBd0IsQ0FBQyxDQUFDO0lBQzNFLGdCQUFNLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsSUFBSSxNQUFNLElBQUksQ0FBQyxFQUFFLGlCQUFpQixFQUFFLHVCQUF1QixDQUFDLENBQUM7SUFDM0YsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO1FBQ2QsT0FBTyxDQUFDLENBQUMsS0FBSyxHQUFHLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQyxHQUFHLE1BQU0sQ0FBQztLQUM1QztTQUFNO1FBQ04sT0FBTyxLQUFLLEdBQUcsTUFBTSxDQUFDO0tBQ3RCO0FBQ0YsQ0FBQztBQVJELHdDQVFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBBQkIgU3dpdHplcmxhbmQgTHRkLlxuICpcbiAqIE1hdGggdXRpbGl0eSBmdW5jdGlvbnNcbiAqL1xuXG5cInVzZSBzdHJpY3RcIjtcblxuaW1wb3J0IGFzc2VydCBmcm9tIFwiLi9hc3NlcnRcIjtcblxuLyoqXG4gKiBAcmV0dXJuIHRydWUgaWZmIGdpdmVuIGFyZ3VtZW50IGlzIGFuIGludGVnZXIgbnVtYmVyXG4gKiBAdGhyb3dzIG5vdGhpbmdcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW50KG46IG51bWJlcik6IGJvb2xlYW4ge1xuXHRpZiAobiA9PT0gbnVsbCB8fCAhaXNGaW5pdGUobikpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblx0cmV0dXJuIChNYXRoLmZsb29yKG4pID09PSBuKTtcbn1cblxuLyoqXG4gKiBSb3VuZHMgLTEuNSB0byAtMiBpbnN0ZWFkIG9mIC0xXG4gKiBSb3VuZHMgKzEuNSB0byArMlxuICogQHRocm93cyB0aW1lem9uZWNvbXBsZXRlLkFyZ3VtZW50Lk4gaWYgbiBpcyBub3QgYSBmaW5pdGUgbnVtYmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByb3VuZFN5bShuOiBudW1iZXIpOiBudW1iZXIge1xuXHRhc3NlcnQoTnVtYmVyLmlzRmluaXRlKG4pLCBcIkFyZ3VtZW50Lk5cIiwgXCJuIG11c3QgYmUgYSBmaW5pdGUgbnVtYmVyIGJ1dCBpczogJWRcIiwgbik7XG5cdGlmIChuIDwgMCkge1xuXHRcdHJldHVybiAtMSAqIE1hdGgucm91bmQoLTEgKiBuKTtcblx0fSBlbHNlIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZChuKTtcblx0fVxufVxuXG4vKipcbiAqIFN0cmljdGVyIHZhcmlhbnQgb2YgcGFyc2VGbG9hdCgpLlxuICogQHBhcmFtIHZhbHVlXHRJbnB1dCBzdHJpbmdcbiAqIEByZXR1cm4gdGhlIGZsb2F0IGlmIHRoZSBzdHJpbmcgaXMgYSB2YWxpZCBmbG9hdCwgTmFOIG90aGVyd2lzZVxuICogQHRocm93cyBub3RoaW5nXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXJGbG9hdCh2YWx1ZTogc3RyaW5nKTogbnVtYmVyIHtcblx0aWYgKC9eKFxcLXxcXCspPyhbMC05XSsoXFwuWzAtOV0rKT98SW5maW5pdHkpJC8udGVzdCh2YWx1ZSkpIHtcblx0XHRyZXR1cm4gTnVtYmVyKHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gTmFOO1xufVxuXG4vKipcbiAqIE1vZHVsbyBmdW5jdGlvbiB0aGF0IG9ubHkgcmV0dXJucyBhIHBvc2l0aXZlIHJlc3VsdCwgaW4gY29udHJhc3QgdG8gdGhlICUgb3BlcmF0b3JcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHBhcmFtIG1vZHVsb1xuICogQHRocm93cyB0aW1lem9uZWNvbXBsZXRlLkFyZ3VtZW50LlZhbHVlIGlmIHZhbHVlIGlzIG5vdCBmaW5pdGVcbiAqIEB0aHJvd3MgdGltZXpvbmVjb21wbGV0ZS5Bcmd1bWVudC5Nb2R1bG8gaWYgbW9kdWxvIGlzIG5vdCBhIGZpbml0ZSBudW1iZXIgPj0gMVxuICovXG5leHBvcnQgZnVuY3Rpb24gcG9zaXRpdmVNb2R1bG8odmFsdWU6IG51bWJlciwgbW9kdWxvOiBudW1iZXIpOiBudW1iZXIge1xuXHRhc3NlcnQoTnVtYmVyLmlzRmluaXRlKHZhbHVlKSwgXCJBcmd1bWVudC5WYWx1ZVwiLCBcInZhbHVlIHNob3VsZCBiZSBmaW5pdGVcIik7XG5cdGFzc2VydChOdW1iZXIuaXNGaW5pdGUobW9kdWxvKSAmJiBtb2R1bG8gPj0gMSwgXCJBcmd1bWVudC5Nb2R1bG9cIiwgXCJtb2R1bG8gc2hvdWxkIGJlID49IDFcIik7XG5cdGlmICh2YWx1ZSA8IDApIHtcblx0XHRyZXR1cm4gKCh2YWx1ZSAlIG1vZHVsbykgKyBtb2R1bG8pICUgbW9kdWxvO1xuXHR9IGVsc2Uge1xuXHRcdHJldHVybiB2YWx1ZSAlIG1vZHVsbztcblx0fVxufVxuIl19